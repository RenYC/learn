# 3.8.1　顺序错误处理

本章前面已经详细介绍了适合 Promise 的错误处理。Promise 的设计局限性(具体来说， 就是它们链接的方式)造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被无意中默默忽略掉。

关于 Promise 错误，还有其他需要考虑的地方。由于一个 Promise 链仅仅是连接到一起的成员Promise，没有把整个链标识为一个个体的实体，这意味着没有外部方法可以用于观察可能发生的错误。

如果构建了一个没有错误处理函数的 Promise 链，链中任何地方的任何错误都会在链中一直传播下去，直到被查看（通过在某个步骤注册拒绝处理函数）。在这个特定的例子中，只要有一个指向链中最后一个 promise 的引用就足够了（下面代码中的 p ），因为你可以在那里注册拒绝处理函数，而且这个处理函数能够得到所有传播过来的错误的通知：
```
// foo(..), STEP2(..) 以及 STEP3(..) 都是支持 promise 的工具

var p = foo(42)
.then(STEP2)
.then(STEP3);
```
虽然这里可能有点鬼祟、令人迷惑，但是这里的 p 并不指向链中的第一个 promise (调用foo(42)产生的那一个)，而是指向最后一个 promise, 即来自调用then(STEP3)的那一个。

还有，这个 Promise 链中的任何一个步骤都没有显式地处理自身错误。这意味着你可以在 p 上注册一个拒绝错误处理函数，对于链中任何位置出现的任何错误，这个处理函数都会得到通知：
```
p.catch(handleErrors);
```
但是，如果链中的任何一个步骤事实上进行了自身的错误处理（可能以隐藏或抽象的不可见的方式），那你的 handleErrors(..) 就不会得到通知。
这可能是你想要的 -- 毕竟这是一个 “已处理的拒绝” -- 但也可能并不是。完全不能得到（对任何“已经处理”的拒绝错误的）错误通知也是一个缺陷，它限制了某些用例的功能。

基本上，这等同于 try..catch 存在的局限：try..catch 可能捕获一个异常并简单的额吞掉它。所以这并不是 Promise 独有的局限性，但可能是我们希望绕过的陷阱。

遗憾的是，很多时候并没有为 Promise 链序列的中间步骤保留的引用。因此，没有这样的引用，你就无法关联错误处理函数来可靠地检查错误。