# 4.1.1　输入和输出

生成器函数是一个特殊的函数，具有前面我们展示的新的执行模式。但是，它仍然是一个函数，这意味着它仍然有一些基本的特性没有改变。
比如，它仍然可以接受参数（即输入），也能够返回值（即输出）。
```
function *foo(x, y) {
  return x * y;
}

var it = foo(6, 7);

var res = it.next();

res.value; // 42
```
我们向 *foo(..) 传入实参 6 和 7 分别作为参数 x 和 y 。*foo(..) 向调用代码返回 42 。

现在我们可以看到生成器和普通函数在调用上的一个区别。显然 foo(6,7) 看起来很熟悉。但难以理解的是，生成器 *foo(..) 并没有像普通函数一样实际运行。

事实上，我们只是创建了一个迭代器对象，把它赋给了一个变量 it ，用于控制生成器 *foo(..) 。然后调用 it.next() ，指示生成器 *foo(..)从当前位置开始继续运行，停在下一个 yield 处或者直到生成器结束。

这个 next(..) 调用的结果是一个对象，它有一个 value 属性，持有从 *foo(..) 返回的值（如果有的话）。换句话说，yield 会导致生成器在执行过程中发送出一个值，这有点类似于中间的 return 。

目前还不清楚为什么需要这一整个间接迭代器对象来控制生成器。会清楚的，我保证。

## 1. 迭代消息传递

除了能够接受参数并提供返回值之外，，生成器甚至提供了更强大更引人注目的内建消息输入输出能力，通过 yield 和 next(..) 实现。

考虑：
```
function *foo(x) {
  var y = x * (yield);
  return y;
}

var it = foo(6);

// 启动foo(..)
it.next();

var res = it.next(7);

res.value; // 42
```
首先，传入6作为参数x。然后调用 it.next() ，这会启动 *foo(..) 。

在 *foo(..) 内部，开始执行语句 var y = x .. ，但随后就遇到了一个 yield 表达式。它就会在这一点上暂停 *foo(..) （在赋值语句中间！），并在本质上要求调用代码为 yield 表达式提供一个结果值。接下来，调用 it.next( 7 ) ，这一句把值 7 传回作为被暂停的 yield 表达式的结果。

所以，这时赋值语句实际上就是 var y = 6 * 7 。现在，return y 返回值 42 作为调用 it.next( 7 )的结果。

注意，这里有一点非常重要，但即使对于有经验的 JavaScript 开发者也很有迷惑性：根据你的视角不同，yield 和 next(..) 调用有一个不匹配。一般来说，需要的 next(..) 调用要比 yield 语句多一个，前面的代码片段有一个 yield 和两个 next(..) 调用。

为什么会有这个不匹配？

因为第一个 next(..) 总是启动一个生成器，并运行到第一个 yield 处。不过，是第二个 next(..) 调用完成第一个被暂停的 yield 表达式，第三个 next(..) 调用完成第二个 yield ，以此类推。

## 2. 两个问题的故事

实际上，你首先考虑的是哪一部分代码将会影响这个不匹配是否被察觉到。 只考虑生成器代码：
```
var y = x * (yield)
return y
```
第一个 yield 基本上是提出了一个问题：“这里我应该插入什么值？”

谁来回答这个问题呢？第一个 next() 已经运行，使得生成器启动并运行到此处，所以显然它无法回答这个问题。因此必须由第二个 next(..) 调用回答第一个 yield 提出的这个问题。

看到不匹配了吗——第二个对第一个？

把视角转化一下：不从生成器的视角看这个问题，而是从迭代器的角度。

为了恰当阐述这个视角，我们还需要解释一下：消息是双向传递的——yield.. 作为一个表达式可以发出消息响应 next(..) 调用，next(..) 也可以向暂停的 yield 表达式发送值。考虑下面这段稍稍调整过的代码：
```
function *foo(x) {
  var y = x * (yield "Hello"); // <-- yield一个值！
  return y
}

var it  = foo(6);

var res = it.next(); // 第一个next(),并不传入任何东西
res.value; // "Hello"

res = it.next(7); // 向等待的yield传入7
res.value // 42
```
yield..和next(..)这一对组合起来，**在生成器的执行过程中**构成了一个双向传递系统。

那么只看下面这一**段迭代器**代码：
```
var res = it.next(); // 第一个next()，并不传入任何东西
res.value; // "Hello"

res = it.next(7); // 向等待的yield传入7
res.value; // 42
```
>我们并没有向第一个 next() 调用发送值，这是有意为之。只有暂停的 yield 才能接受这样一个通过 next(..) 传递的值，而在生成器的起始处我们调用第一个 next() 时，还没有暂停的 yield 来接受这样一个值。规范和所有兼容浏览器都会默默丢弃传递给第一个 next() 的任何东西。传值过去仍然不是一个好思路，因为你创建了沉默的无效代码，这会让人迷惑。因此，启动生成器时一定要用不带参数的 next() 。

第一个 next() 调用（没有参数的）基本上就是在提出一个问题：“生成器 *foo(..) 要给我的下一个值是什么”。谁来回答这个问题呢？第一个 yield "hello" 表达式。

看见了吗？这里没有不匹配。

根据你认为提出问题的是谁，yield 和 next(..) 调用之间要么有不匹配，要么没有。

但是，稍等！与 yield 语句的数量相比，还是多出了一个额外的 next() 。所以，最后一个it.next(7) 调用再次提出了这样的问题：生成器将要产生的下一个值是什么。但是，再没有 yield语句来回答这个问题了，是不是？那么谁来回答呢？

return 语句回答这个问题！

如果你的生成器中没有 return 的话——在生成器中和在普通函数中一样，return 当然不是必需的——总有一个假定的 / 隐式的 return; （也就是 return undefined; ），它会在默认情况下回答最后的 it.next(7) 调用提出的问题。

这样的提问和回答是非常强大的：通过 yield 和 next(..) 建立的双向消息传递。但目前还不清楚这些机制是如何与异步流程控制联系到一起的。会清楚的！