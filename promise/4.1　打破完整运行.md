# 4.1　打破完整运行

在第 1 章中，我们解释了 JavaScript 开发者在代码中几乎普遍依赖的一个假定：一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打断它并插入其间。

可能看起来似乎有点奇怪，不过 ES6 引入了一个新的函数类型，它并不符合这种运行到结束的特性。这类新的函数被称为生成器。

考虑如下这个例子来了解其含义：
```
var x = 1;

function foo() {
  x++;
  bar();  // <-- 这一行是什么作用？
  console.log('x:', x)
}

function bar() {
  x++
}

foo();  // x: 3
```
在这个例子中，我们确信 bar() 会在 x++ 和 console.log(x) 之间运行。但是，如果 bar() 并不在那里会怎样呢？显然结果就会是 2 ，而不是 3 。

现在动脑筋想一 下。如果 bar() 并不在那 儿，但出于某种原因它仍然可以在 x++  和 console.log(x)语句之间运行，这又会怎样呢？这如何才会成为可能呢？

如果是在抢占式多线程语言中，从本质上说，这是可能发生的，bar() 可以在两个语句之间打断并运行。但 JavaScript 并不是抢占式的，（目前）也不是多线程的。然而，如果 foo() 自身可以通过某种形式在代码的这个位置指示暂停的话，那就仍然可以以一种合作式的方式实现这样的中断（并发）。

>这里我之所以使用了“合作式的”一词，不只是因为这与经典并发术语之间的关联（参见第 1 章）；还因为你将会在下一段代码中看到的，ES6 代码中指示暂停点的语法是yield ，这也礼貌地表达了一种合作式的控制放弃。

下面是实现这样的合作式并发的 ES6 代码：
```
var x = 1;

function *foo(){
  x++;
  yield // 暂停
  console.log('x:', x)
}

function bar() {
  x++;
}
```

>很可能你看到的其他多数 JavaScript 文档和代码中的生成器声明格式都是function* foo() { .. } ，而不是我这里使用的 function \*foo() { .. } ：唯一区别是 \*位置的风格不同。这两种形式在功能和语法上都是等同的，还有一种是 function*foo(){.. } （没有空格）也一样。
两种风格，各有优缺，但总体上我比较喜欢 function *foo..的形式，因为这样在使用 *foo() 来引用生成器的时候就会比较一致。如果只用 foo() 的形式，你就不会清楚知道我指的是生成器还是常规函数。这完全是一个风格偏好问题。

现在，我们要如何运行前面的代码片段，使得 bar() 在 *foo() 内部的 yield 处执行呢？
```
// 构造一个迭代器it来控制这个生成器
var it = foo();

// 这里启动foo()!
it.next();
x; // 2
bar();
x: // 3
it.next(); // x: 3
```
好吧，这两段代码中有很多新知识，可能会让人迷惑，所以这里有很多东西需要学习。在解释 ES6 生成器的不同机制和语法之前，我们先来看看运行过程。

(1) it = foo() 运算并没有执行生成器 *foo() ，而只是构造了一个迭代器 （iterator），这个迭代器会控制它的执行。后面会介绍迭代器。

(2) 第一个 it.next() 启动了生成器 *foo() ，并运行了 *foo() 第一行的 x++ 。

(3) *foo() 在 yield 语句处暂停，在这一点上第一个 it.next() 调用结束。此时 *foo() 仍在运行并且是活跃的，但处于暂停状态。

(4) 我们查看 x 的值，此时为 2 。

(5) 我们调用 bar() ，它通过 x++ 再次递增 x 。

(6) 我们再次查看 x 的值，此时为 3 。

(7) 最后的 it.next() 调用从暂停处恢复了生成器 *foo() 的执行，并运行 console.log(..) 语句，这条语句使用当前 x 的值 3 。

显然，foo() 启动了，但是没有完整运行，它在 yield 处暂停了。后面恢复了 foo() 并让它运行到结束，但这不是必需的。

因此，生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。尽管现在还不是特别清楚它的强大之处，
但随着对本章后续内容的深入学习，我们会看到它将成为用于构建以生成器作为异步流程控制的代码模式的基础构件之一。