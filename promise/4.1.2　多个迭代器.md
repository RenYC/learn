# 4.1.2　多个迭代器

从语法使用的方面来看，通过一个迭代器控制生成器的时候，似乎是在控制声明的生成器函数本身。但有一个细微之处很容易忽略：每次构建一个迭代器 ，实际上就隐式构建了生成器的一个实例，通过这个迭代器 来控制的是这个生成器实例。

同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互：
```
function *foo() {
  var x = yield 2;
  z++;
  var y = yield(x*z);
  console.log(x, y, z)
}

var z = 1;

var it1 = foo();
var it2 = foo();

var val1 = it1.next().value; // 2 <-- yield 2
var val2 = it2.next().value; // 2 <-- yield 2

val1 = it1.next(val2 * 10).value; // 40 <-- x:20, z:2
val2 = it2.next(val1 * 5).value; // 600 <-- x:200, z:3

it1.next(val2 / 2); // y:300
                    // 20 300 3
it2.next(val1 / 4); // y:10
                    // 200 10 3
```
>同一个生成器的多个实例并发运行的最常用处并不是这样的交互，而是生成器在没有输入的情况下，可能从某个独立连接的资源产生自己的值。下一节中我们会详细介绍值产生。

我们简单梳理一下执行流程。

(1) *foo() 的两个实例同时启动，两个 next() 分别从 yield 2 语句得到值 2 。

(2) val2 * 10 也就是 2 * 10 ，发送到第一个生成器实例 it1 ，因此 x 得到值 20 。z 从 1 增加到 2，然后 20 * 2 通过 yield 发出，将 val1 设置为 40 。

(3) val1 * 5 也就是 40 * 5 ，发送到第二个生成器实例 it2 ，因此 x 得到值 200 。z 再次从 2 递增到 3 ，然后 200 * 3 通过 yield 发出，将 val2 设置为 600 。

(4) val2 / 2 也就是 600 / 2 ，发送到第一个生成器实例 it1 ，因此 y 得到值 300 ，然后打印出 x yz 的值分别是 20 300 3 。

(5) val1 / 4 也就是 40 / 4 ，发送到第二个生成器实例 it2 ，因此 y 得到值 10 ，然后打印出 x y z的值分别为 200 10 3 。

### 交替执行

回想一下 1.3 节中关于完整运行的这个场景：
```
var a = 1;
var b = 2;

function foo() {
  a++;
  b = b * a;
  a = b + 3;
}

function bar() {
  b--;
  a = 8 + b;
  b = a * 2;
}
```
如果是普通的 JavaScript 函数的话，显然，要么是 foo() 首先运行完毕，要么是 bar() 首先运行完毕，但 foo() 和 bar() 的语句不能交替执行。所以，前面的程序只有两种可能的输出。

但是，使用生成器的话，交替执行（甚至在语句当中！）显然是可能的：
```
var a = 1;
var b = 2;

function *foo() {
  a++;
  yield;
  b = b * a;
  a = (yield b) + 3;
}

function *bar() {
  b--;
  yield;
  a = (yield 8) + b;
  b = a * (yield 2)
}
```
根据迭代器控制的 *foo() 和 *bar() 调用的相对顺序不同，前面的程序可能会产生多种不同的结果。换句话说，通过两个生成器在共享的相同变量上的迭代交替执行，我们实际上可以（以某种模拟的方式）印证第 1 章讨论的理论上的多线程竞态条件环境。

首先，来构建一个名为 step(..) 的辅助函数，用于控制迭代器 ：
```
function step(gen) {
  var it = gen();
  var last;

  return function() {
    // 不管yield出来的是什么，下一次都要把它原样传回去！
    last = it.next(last).value;
  }
}
```
step(..) 初始化了一个生成器来创建迭代器it ，然后返回一个函数，这个函数被调用的时候会将迭代器 向前迭代一步。另外，前面的 yield 发出的值会在下一步发送回去。于是，yield 8 就是 8 ，而yield b 就是 b （yield 发出时的值）。

现在，只是为了好玩，我们来试验一下交替运行 *foo() 和 *bar() 代码块的效果。我们从乏味的基本情况开始，确保 *foo() 在 *bar() 之前完全结束（和第 1 章中做的一样）：
```
// 确保重新设置a和b
a = 1;
b = 2;

var s1 = step(foo);
var s2 = step(bar);

// 首次运行 *foo()
s1();
s1();
s1();

// 现在运行*bar()
s2();
s2();
s2();
s2();

console.log(a, b); // 11 22
```
最后的结果是 11 和 22，和第 1 章中的版本一样。现在交替执行顺序，看看 a 和 b 的值是如何改变的：
```
// 确保重新设置a和b
a = 1;
b = 2;

var s1 = step(foo);
var s2 = step(bar);

s2(); // b--
s2(); // yield 8
s1(); // a++;
s2(); // a = 8 + b;
      // yield 2
s1(); // b = b * a
      // yield b;
s1(); // a = b + 3;
s2(); // b = a * 2;
```
在告诉你结果之前，你能推断出前面的程序运行后 a 和 b 的值吗？不要作弊！
```
console.log(a, b); // 12 18
```
>作为留给大家的练习，请试着重新安排 s1() 和 s2() 的调用顺序，看看还能够得到多少种结果组合。不要忘了，你总是需要 3 次 s1() 调用和 4 次 s2() 调用。回忆一下前面关于 next() 和 yield 匹配的讨论，想想为什么。

当然，你基本不可能故意创建让人迷惑到这种程度的交替运行实际代码，因为这给理解代码带来了极大的难度。但这个练习很有趣，对于理解多个生成器如何在共享的作用域上并发运行也有指导意义，因为这个功能有很多用武之地。

我们将在 4.6 节中更深入讨论生成器并发。