# 绝望得陷阱

Jeff Atwood 多年前曾提出：通常编程语言构建的方式是，默认情况下，，开发者陷入“绝望的陷阱 ”，要为错误付出代价，
只有更努力才能做对。他呼吁我们转而构建一个“成功的坑”（pit of success），其中默认情况下你能够得到想要的结果（成功），想出错很难。

毫无疑问，Promise 错误处理就是一个“绝望的陷阱”设计。默认情况下，它假定你想要 Promise状态吞掉所有的错误。如果你忘了查看这个状态，这个错误就会默默地（通常是绝望地）在暗处凋零死掉。

为了避免丢失被忽略和抛弃的 Promise 错误，一些开发者表示，Promise 链的一个最佳实践就是最后总以一个 catch(..) 结束，比如：
```
var p = Promise.resolve(42);

p.then(
  function fulfilled(msg) {
    // 数字没有 string 函数，所以会抛出错误
    console.log(msg.toLowerCase())
  }
)
.catch(handleErrors)
```
因为我们没有为 then(..) 传入拒绝处理函数，所以默认的处理函数被替换掉了，，而这仅仅是把错误传递给了链中的下一个 promise。
因此，进入 p 的错误以及 p 之后进入其决议（就像msg.toLowerCase() ）的错误都会传递到最后的 handleErrors(..) 。

问题解决了，对吧？没那么快！

如果 handleErrors(..) 本身内部也有错误怎么办呢？谁来捕捉它？还有一个没人处理的 promise：catch(..) 返回的那一个。
我们没有捕获这个 promise 的结果，也没有为其注册拒绝处理函数。

你并不能简单地在这个链尾端添加一个新的 catch(..) ，因为它很可能会失败。任何 Promise 链的最后一步，不管是什么，总是存在着在未被查看的 Promise 中出现未捕获错误的可能性，尽管这种可能性越来越低。

看起来好像是个无解的问题吧？