# 3.5.3　成功的坑

接下来的内容只是理论上的，关于未来的 Promise 可以变成什么样。。我相信它会变得比现在我们所拥有的高级得多。我认为这种改变甚至可能是后 ES6 的，
因为我觉得它不会打破与 ES6 Promise 的web 兼容性。还有，如果你认真对待的话，它可能是可以 polyfill/prollyfill 的。我们来看一下。

默认情况下，Promsie 在下一个任务或时间循环 tick 上（向开发者终端）报告所有拒绝，如果在这个时间点上该 Promise 上还没有注册错误处理函数。

如果想要一个被拒绝的 Promise 在查看之前的某个时间段内保持被拒绝状态，可以调用 defer() ，这个函数优先级高于该 Promise 的自动错误报告。

如果一个 Promise 被拒绝的话，默认情况下会向开发者终端报告这个事实（而不是默认为沉默）。可以选择隐式（在拒绝之前注册一个错误处理函数）
或者显式（通过 defer() ）禁止这种报告。在这两种情况下，都是由你来控制误报的情况。

考虑：
```
var p = Promise.reject("Oops").defer();

// foo(..)是支持Promise的
foo(42)
.then(
  function fulfilled(){
    return p
  },
  function rejected(err){
    // 处理foo(..)错误
  }
)
```
创建 p 的时候，我们知道需要等待一段时间才能使用或查看它的拒绝结果，所以我们就调用 defer()，这样就不会有全局报告出现。为了便于链接，defer() 只是返回这同一个 promise。

从 foo(..) 返回的 promise 立刻就被关联了一个错误处理函数，所以它也隐式消除了出错全局报告。

但是，从 then(..) 调用返回的 promise 没有调用 defer() ，也没有关联错误处理函数，所以如果它（从内部或决议处理函数）拒绝的话，就会作为一个未捕获错误被报告到开发者终端。

这种设计就是成功的坑。默认情况下，所有的错误要么被处理要么被报告，这几乎是绝大多数情况下几乎所有开发者会期望的结果。你要么必须注册一个处理函数要么特意选择退出，并表明你想把错误处理延迟到将来 。你这时候是在为特殊情况主动承担特殊的责任。

这种方案唯一真正的危险是，如果你 defer() 了一个 Promise，但之后却没有成功查看或处理它的拒绝结果。

但是，你得特意调用 defer() 才能选择进入这个绝望的陷阱（默认情况下总是成功的坑）。所以这是你自己的问题，别人也无能为力。

我认为 Promise 错误处理还是有希望的（后 ES6）。我希望权威组织能够重新思考现状，考虑一下这种修改。同时，你也可以自己实现这一点（这是一道留给大家的挑战性习题！），或者选择更智能的 Promise 库为实现！